from multiprocessing import Value
import os
import sys, signal
import yaml
import json
import math
import copy
from datetime import datetime, timezone, timedelta
from apscheduler.schedulers.qt import QtScheduler
from glob import glob

# import PySide6 modules
from PySide6 import QtWidgets, QtGui
from PySide6.QtWidgets import QFileDialog, QMessageBox
from PySide6.QtCore import Qt, QAbstractTableModel, QTimer, QDateTime

# import autogenerated userinterface files
from ui.QPLmainwindow_ui import Ui_MainWindow
from ui.Dialog_edit_ui import Ui_EditDialog
from ui.dialog_choice_ui import Ui_DialogChoice
from ui.Dialog_settings_ui import Ui_DialogSettings

# import local modules
from point4D import Point4d
import SKconnect
import iofunctions
import pointbuffer as pb
import celnav as cn
import deadreconing as dr
from to_pdf import mk_pdf 


# Global variables:
conf_file = os.path.dirname(os.path.realpath(__file__)) + "/" + "data/conf.json"

# global variable 'conf' holds the configuration dictionary
with open(conf_file, "r") as conffile:
        conf = json.loads(conffile.read())

QPlog = []

buffer = pb.PointBuffer(15)

status = "undefined"

keys_to_head = {
        "log": "Log\n(nm)",
        "enginehours": "Engine\n(h)",
        "cog": "COG",
        "sog": "SOG\n(kts)",
        "stw": "STW",
        "heading": "Heading",
        "airpressure": "Baro \n(hPa)",
        "airtemperature": "Airtemp \n(Â°C)",
        "twd": "TWD",
        "tws": "TWS\n(kts)",
        "humidity": "Humidity\n(%)",
        "text": "text",
        "fixtype": "Fix",
        "hdop": "HDOP\n(m)",
        "visibility": "Vis.",
        "cloudcover": "Cloud\n(8th)",
        "seastate": "Sea",
        "crewNames": "Crew",
        "place": "Place",
        "rpm": "RPM",
        "status": "Status",
}   



# Functions:

def loadlastlog(logdir):
    """Load log files from the 2 most recent months in the log directory if they exist"""
    loglist = glob(f"{logdir}/*.json")
    loglist.sort()
    if len(loglist) == 0:
        return []
    elif len(loglist) == 1:
        return iofunctions.getQPlog(loglist[0])
    else:
        lastlog = iofunctions.getQPlog(loglist[len(loglist)-1])
        lastlog.extend(iofunctions.getQPlog(loglist[len(loglist)-2]))
        iofunctions.cleanup(lastlog)
        return lastlog



eventlog = conf["enableeventlog"]
auto_on = not(conf["manualmode"])



def toheaders(conf):
    headers = ["Time", "Position"]
    for key in conf["showkeys"]:
        if key in keys_to_head:
            headers.append(keys_to_head[key])
        else:
            headers.append(key)
    return headers

def h_to_key(head):
    head_to_key = {v: k for k, v in keys_to_head.items()}


  

QPlog = loadlastlog(conf["qplogfolder"])


# Qt Mainwindow and Model:

class QPlogModel(QAbstractTableModel):
    """the data model for use with QtableView"""
    def __init__(self, data, headers):
        super().__init__()
        self._data = data
        self._headers = headers
        self.head_to_key = {v: k for k, v in keys_to_head.items()}

    def data(self, index, role):
        column = index.column()
        

        column_key = dictkey = self._headers[column]
        if dictkey == "Time" or dictkey == "Position":
            dictkey = "point"
        elif dictkey in self.head_to_key:
            dictkey = self.head_to_key[dictkey]
        else:
            pass

        if role == Qt.DisplayRole:
            try:
                value = self._data[index.row()][dictkey]
            except KeyError:
                return ""

            # if isinstance(value, datetime):
            #     return value.strftime("%H:%M")

            if column_key == "Time":
                logtime = value.time.astimezone(timezone(timedelta(hours=conf["utc_offset"])))
                return logtime.strftime("%H:%M")
            
            elif column_key == "Position":             
                return f"{value.getDMpos()[0]} \n {value.getDMpos()[1]}"
            
            elif isinstance(value, list):
                s = ""
                for i in value:
                    s += (i + ", ")
                return s
            else:
                return value
        
        if role == Qt.FontRole: 
            font = QtGui.QFont()
            font.setPointSize(10)           
            if column_key == "Position":
                return font
            font.setPointSize(12)
            return font
        
        if role == Qt.TextAlignmentRole:
            if column_key == "Position":
                return Qt.AlignVCenter + Qt.AlignRight


    def rowCount(self, index):
        # The length of the outer list.
        return len(self._data)

    def columnCount(self, index):
        # The length of our headers.
        return len(self._headers)

    def headerData(self, section, orientation, role):
        # section is the index of the column/row.
        if role == Qt.DisplayRole:
            if orientation == Qt.Horizontal:
                return str(self._headers[section])

            if orientation == Qt.Vertical:
                value = self._data[section]["point"].time 
                return value.strftime("%d.%m")   # str(section)
            

class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)


        self.cellnav_window = None
        self.model = QPlogModel(QPlog, toheaders(conf))
        self.logTableView.setModel(self.model)
        self.logTableView.resizeRowsToContents()
        self.logTableView.resizeColumnsToContents()

        self.actionSave.triggered.connect(self.save_QPlog)
        self.actionPrintPDF.triggered.connect(self.printPDF)
        self.actionOpen.triggered.connect(self.openDialog)
        self.actionAdd.triggered.connect(self.addDialog)
        self.actionPreferences.triggered.connect(self.openSettings)
        self.actionEdit.triggered.connect(self.openEdit)
        self.logTableView.doubleClicked.connect(self.openEdit)

        self.actionNew_Entry.triggered.connect(self.openNew)
        self.actionAddEntry.triggered.connect(self.addSKentry)
        self.actionDelete_Entry.triggered.connect(self.deleteEntry)
        self.actionSort.triggered.connect(self.sortandclean)
        self.actionDeadReconing.triggered.connect(self.openDR)
        self.actionAstro.triggered.connect(self.openCelNav)
        self.actionQuit.triggered.connect(app.quit, Qt.QueuedConnection)

        self.actionstartstopp.setChecked(auto_on)
        self.actionstartstopp.toggled.connect(self.toggle_autolog)
        self.scheduler = QtScheduler()
        self.scheduler.add_job(self.auto_entry_status, id="track", trigger="cron", minute=f"*/{int(conf['trackinterv'])}")
        self.scheduler.add_job(self.auto_entry, id="entry", trigger="cron", hour=f"*/{conf['loginterv']}")
        self.scheduler.start()

        self.status_label = QtWidgets.QLabel("Starting up")
        self.auto_entry_label = QtWidgets.QLabel("Auto Entry: ON")
        self.auto_entry_label.setText("Auto Entry: ON") if auto_on else self.auto_entry_label.setText("Auto Entry: OFF")    
        self.timezone_label = QtWidgets.QLabel(f"   Timezone: UTC{math.trunc(conf['utc_offset']):+03}:{(abs(conf['utc_offset']-math.trunc(conf['utc_offset']))*60):02.0f} ")
        self.statusbar.addWidget(self.status_label)
        self.statusbar.addWidget(self.timezone_label)
        self.statusbar.addPermanentWidget(self.auto_entry_label)
        


    def firststart(self):
        """Function to run on first start of the program"""
        msg = QMessageBox.information(self, "Warning", 
                                      "Please configure some basic settings in the settings dialog", 
                                      QMessageBox.Ok)
        pref_dlg = SettingsDialog(self, conf)
        result = pref_dlg.exec()
        if result == QtWidgets.QDialog.Rejected:
            sys.exit()
        if result == QtWidgets.QDialog.Accepted:
            with open(conf_file, "w") as conffile:
                conffile.write(json.dumps(conf, indent=4))
            del pref_dlg
            if conf["qplogfolder"] == "":
                sys.exit()
            else:
                if not os.path.exists(conf["qplogfolder"]):
                    os.makedirs(conf["qplogfolder"])
                QPlog = loadlastlog(conf["qplogfolder"])


    def printPDF(self):
        keys = ["Time", "Position"] + conf["showkeys"]
        fileName = QFileDialog.getSaveFileName(self, "Open File", dir=conf["qplogfolder"],
                                                filter="PDF files (*.pdf)")
        mk_pdf(QPlog, conf, 8, fileName[0])
        
        

    def closeEvent(self, event):
        """code to clean up on closing the main window"""
        cl = self.save_QPlog()
        if cl == 1:
            event.ignore()
        else:
            event.accept()

    def toggle_autolog(self):
        """Slot for the actionstartstopp action to toggle the automatic logging"""
        global auto_on
        auto_on = self.actionstartstopp.isChecked()
        if auto_on:
            self.auto_entry_label.setText("Auto Entry: ON")
        else:
            self.auto_entry_label.setText("Auto Entry: OFF")
        #print(auto_on)


    def openDialog(self):
        """Open a File Dialog to open a new log file replacing the current log"""
        fileName = QFileDialog.getOpenFileName(self, "Open File",
                                                "",
                                                "JSON files (*.json)")
        self.active_folder = os.path.dirname(fileName[0])
        log = iofunctions.getQPlog(fileName[0])
        QPlog.clear()
        QPlog.extend(log)
        self.model.layoutChanged.emit()


    def addDialog(self):
        """Open a File Dialog to add a log file to the current logbook"""
        fileName = QFileDialog.getOpenFileName(self, "Open File",
                                                "",
                                                "JSON files (*.json)")
        self.active_folder = os.path.dirname(fileName[0])
        log = iofunctions.getQPlog(fileName[0])
        QPlog.extend(log)
        self.model.layoutChanged.emit() 


    def openDR(self):
        """Open the Dead Reckoning Dialog"""
        self.sortandclean()
        point = QPlog[len(QPlog)-1]["point"]
        dr_dlg = dr.DeadReckoning(self, point)
        if dr_dlg.exec() == QtWidgets.QDialog.Accepted:
            new_entry = dr_dlg.get_entry()
            QPlog.append(new_entry)
            self.model.layoutChanged.emit()
        else:
            pass



    def openCelNav(self, checked):
        """Open the celestial navigation Window"""
        if self.cellnav_window is None:
            self.cellnav_window = cn.CelNavUi(QPlog, self.model, QPlog[len(QPlog)-1]["point"], conf["indexerror"], conf["hightofeye"])
            self.cellnav_window.show()
        else:
            self.cellnav_window.close()
            self.cellnav_window = None


    # def saveasDialog(self):
    #     path = self.active_folder
    #     safeName = QFileDialog.getSaveFileName(self, "Save Log", path, "YAML(*.yml);; JSON(*.json)")
    #     saveLog(safeName)

    def save_QPlog(self):
        """ Save the current log to the active Folder splits the log into monthly files and promps
        the user to save or merge the files"""
        to_save = iofunctions.splitmonthly(QPlog)
        for key in to_save:
            try:
                with open(f"{conf['qplogfolder']}/{key}.json", "r") as file:
                    #oldlog = iofunctions.deserialize_log(file.read())
                    oldjson = file.read()
                    newjson = iofunctions.serialize_log(to_save[key])
                    if oldjson == newjson:
                        pass
                    else:
                        choice = ChoiceDialog(self, file)
                        choice.exec()
                        if choice.do == "overwrite":
                            with open(f"{conf['qplogfolder']}/{key}.json", "w") as file:
                                file.write(iofunctions.serialize_log(to_save[key]))
                            return 0
                        elif choice.do == "merge":
                            with open(f"{conf['qplogfolder']}/{key}.json", "r") as file:
                                oldlog = iofunctions.deserialize_log(file.read())
                            oldlog.extend(to_save[key])
                            oldlog = iofunctions.cleanup(oldlog)
                            with open(f"{conf['qplogfolder']}/{key}.json", "w") as file:
                                file.write(iofunctions.serialize_log(oldlog))
                            return 0
                        elif choice.do == "discard":
                            return 0
                        elif choice.do == "saveas":
                            self.savename = QFileDialog.getSaveFileName(self, "Save Log", conf["qplogfolder"], "JSON(*.json)")
                            with open(self.savename[0], "w") as file:
                                file.write(iofunctions.serialize_log(to_save[key]))
                        elif choice.do == "cancel":
                            return 1
                        else:
                            pass
            except FileNotFoundError:
                with open(f"{conf['qplogfolder']}/{key}.json", "w") as file:
                    file.write(iofunctions.serialize_log(to_save[key]))



    def openEdit(self):
        """Open the Edit dialog with the crrently highlited entry"""
        index = self.logTableView.currentIndex().row()
        current_entry = QPlog[index]
        dlg = EditDialog(self, current_entry)
        dlg.exec()
        if dlg.entry != {}:
            QPlog[index] = dlg.entry
            self.model.layoutChanged.emit()
        else:
            pass
        del dlg


    def openSettings(self):
        """Open the Settings Dialog"""
        pref_dlg = SettingsDialog(self, conf)
        pref_dlg.exec()
        with open(conf_file, "w") as conffile:
            conffile.write(json.dumps(conf, indent=4))
        del pref_dlg
        self.model = QPlogModel(QPlog, toheaders(conf))
        self.logTableView.setModel(self.model)
        self.logTableView.resizeRowsToContents()
        self.logTableView.resizeColumnsToContents()
        self.timezone_label.setText(f"   Timezone: UTC{math.trunc(conf['utc_offset']):+03}:{(abs(conf['utc_offset']-math.trunc(conf['utc_offset']))*60):02.0f} ")


    def openNew(self):
        """Open the Edit dialog without data to create a new entry"""
        dlg = EditDialog(self, {})
        dlg.exec()
        if dlg.entry != {}:
            QPlog.append(copy.deepcopy(dlg.entry))
            self.model.layoutChanged.emit()
        else:
            pass
        del dlg
    
    def auto_entry(self):
        """Add a new entry to the logbook in regular interfals"""
        if auto_on and conf["enableauto"]:
            if pb.getStatus(buffer.getdata(), status, conf) in ("moving", "motoring", "sailing"):
                self.addSKentry()

    def auto_entry_status(self):
        """ Automatically adds a new entry to the logbook when the navigation status changes.
        """

        if conf["enableeventlog"] and auto_on:
            global status
            # old_status = pb.getStatus(buffer.getdata(), status, conf)
            old_status = status
            np = SKconnect.getSKpoint4D(conf)
            if np:
                buffer.append(np)
                pointlist = buffer.getdata()
                status = pb.getStatus(pointlist, status, conf)
                self.status_label.setText(f" Status: {status}")
                print(status)
            if status == "moving" and (old_status == "stopped" or old_status == "undefined"):
                pt = pointlist[len(pointlist)-5]
                self.addSKentry(status="moving", point=pt, place=pt.getplace())
            elif status == "stopped" and (old_status == "moving" or old_status == "motoring"):
                pt = pointlist[len(pointlist)-1]
                self.addSKentry(status="stopped", place=pt.getplace())
            elif status == "motoring" and (old_status == "stopped" or old_status == "undefined"):
                pt = pointlist[len(pointlist)-5]
                self.addSKentry(status="motoring", place=pt.getplace())
            elif status == "motoring" and (old_status == "sailing" or old_status == "moving"):
                pt = pointlist[len(pointlist)-1]
                self.addSKentry(status="motoring")
            elif status == "sailing" and (old_status == "motoring" or old_status == "moving"):
                pt = pointlist[len(pointlist)-1]
                self.addSKentry(status="sailing")
            else:
                pass            
        else:
            pass

    def addSKentry(self, **kwargs):
        """Add a new entry to the logbook with the current values from the SignalK server
        and additional values from the kwargs"""
        entry = SKconnect.getSKpath(conf)        
        if entry:
            entry.update(kwargs)
            place = entry["point"].getplace()
            entry["place"] = place
            QPlog.append(entry)
            self.model.layoutChanged.emit()
        else:
            pass

    def deleteEntry(self):
        """Delete the currently highlited entry"""
        index = self.logTableView.currentIndex().row()
        del QPlog[index]
        self.model.layoutChanged.emit()

    def sortandclean(self):
        """Sort the logbook and remove duplicates"""
        global QPlog
        log = iofunctions.cleanup(QPlog)
        QPlog.clear()
        QPlog.extend(log)
        self.model.layoutChanged.emit()


# Dialogs:

class ChoiceDialog(Ui_DialogChoice, QtWidgets.QDialog):
    """Dialog class for choosing between saving, merging, discarding and overwriting a log file"""
    def __init__(self, parent=None, file=None):
        super().__init__(parent)
        self.setupUi(self)
        self.file = file
        self.do = ""
        self.label_filename.setText(file.name)
        self.buttonBox.accepted.connect(self.overwrite)
        self.buttonBox.rejected.connect(self.cancel)
        self.mergeButton.clicked.connect(self.merge)
        self.discardButton.clicked.connect(self.discard)
        self.saveasButton.clicked.connect(self.save_as)

    def save_as(self):
        self.do = "saveas"
        self.close()

    def cancel(self):
        self.do = "cancel"
        self.close()

    def overwrite(self):
        self.do = "overwrite"
        self.close()

    def merge(self):
        self.do = "merge"
        self.close()

    def discard(self):
        self.do = "discard"
        self.close()


class EditDialog(Ui_EditDialog, QtWidgets.QDialog):
    """Dialog class for editing a log entry"""
    def __init__(self, parent=None, ent={}):
        super().__init__(parent)
        self.setupUi(self)
        self.entry = ent
        if self.entry != {}:
            self.updatevalues()

        self.buttonBox.accepted.connect(self.applyValues)
        self.buttonBox.rejected.connect(self.cancel_edit)
        self.updateButton.clicked.connect(self.update_from_SK)

        self.delCrewButton.clicked.connect(self.removecrew)
        self.addCrewButton.clicked.connect(self.addcrew)
        self.pushButton_get_place.clicked.connect(self.getplace)


    def removecrew(self):
        i = self.crewBox.currentRow()
        self.crewBox.takeItem(i)

    def addcrew(self):
        c = self.crewEdit.text()
        if c :
            self.crewBox.addItem(c)
            self.crewEdit.clear()

    def getplace(self):
        lon = self.spinBox_lon_deg.value() + self.doubleSpinBox_lon_min.value()/60
        lat = self.spinBox_lat_deg.value() + self.doubleSpinBox_lat_min.value()/60
        if self.comboBox_ns.currentText() == "S":
            lat = -lat
        if self.comboBox_we.currentText() == "W":
            lon = -lon
        time = self.dateTimeEdit.dateTime()
        dt = datetime.fromisoformat(time.toString(format= Qt.ISODate))
        p = Point4d(dt, lat, lon)
        place = p.getplace()
        self.lineEdit_place.setText(place)

    def update_from_SK(self):
        """Update the dialog with the current values from the SignalK server"""
        self.entry = SKconnect.getSKpath(conf)
        if self.entry:
            #print(self.entry)
            self.updatevalues()
        else:
            pass


    def updatevalues(self):
        """Update the dialog with the values from the current entry"""
        if isinstance(self.entry["point"], Point4d):
            #print(self.entry["point"].time)
            qtime = QDateTime.fromString(self.entry["point"].time.isoformat(), Qt.ISODate)
            self.dateTimeEdit.setDateTime(qtime)
            st = self.dateTimeEdit.dateTime()
            # position
            self.comboBox_ns.addItems(["N", "S"])
            self.comboBox_we.addItems(["E", "W"])
            self.comboBox_ns.setCurrentIndex(0) if self.entry["point"].lat > 0 else self.comboBox_ns.setCurrentIndex(1)
            self.comboBox_we.setCurrentIndex(0) if self.entry["point"].lon > 0 else self.comboBox_we.setCurrentIndex(1)
            self.spinBox_lat_deg.setValue(math.trunc(abs(self.entry["point"].lat)))
            self.doubleSpinBox_lat_min.setValue((abs(self.entry["point"].lat) - math.trunc(abs(self.entry["point"].lat))) * 60)
            self.spinBox_lon_deg.setValue(math.trunc(abs(self.entry["point"].lon)))
            self.doubleSpinBox_lon_min.setValue((abs(self.entry["point"].lon) - math.trunc(abs(self.entry["point"].lon))) * 60)
        else:
            pass
        if "fixtype" in self.entry:
            self.sourceEdit.setText(self.entry["fixtype"])
        if "log" in self.entry:
            self.logEdit.setValue(self.entry["log"])
        if "cog" in self.entry:
            self.cogEdit.setValue(self.entry["cog"])
        if "heading" in self.entry:
            self.headingEdit.setValue(self.entry["heading"])
        if "sog" in self.entry:
            self.sogEdit.setValue(self.entry["sog"])
        if "stw" in self.entry:
            self.stwEdit.setValue(self.entry["stw"])
        if "enginehours" in self.entry:
            self.engineEdit.setValue(self.entry["enginehours"])
        if "tws" in self.entry:
            self.twsEdit.setValue(self.entry["tws"])
        if "twd" in self.entry:
            self.twdEdit.setValue(self.entry["twd"])
        if "airpressure" in self.entry:
            self.pressureEdit.setValue(self.entry["airpressure"])
        if "airtemperature" in self.entry:
            self.airtempSpinBox.setValue(self.entry["airtemperature"])
        if  "seastate" in self.entry:
            self.seastateBox.setCurrentIndex(self.entry["seastate"])
        if "cloudcover" in self.entry:
            self.cloudcoverSpinBox.setValue(self.entry["cloudcover"])
        if "visibility" in self.entry:
            self.visibilityBox.setCurrentIndex(self.entry["visibility"])
        if "crewNames" in self.entry:
            self.crewBox.clear()
            for name in self.entry["crewNames"]:
                self.crewBox.addItem(name)
        if "place" in self.entry:
            self.lineEdit_place.setText(self.entry["place"])
        if "text" in self.entry:
            self.TextEdit.setPlainText(self.entry["text"])


        
    def applyValues(self):
        """Apply the values from the dialog to the current entry"""
        if self.spinBox_lat_deg.value() == 0 and self.doubleSpinBox_lat_min.value() == 0 and self.spinBox_lon_deg.value() == 0 and  self.doubleSpinBox_lon_min.value() == 0:
            self.entry = {}
        time = self.dateTimeEdit.dateTime()
        dt = datetime.fromisoformat(time.toString(format= Qt.ISODate))
        pos = iofunctions.mk_decpos(self.spinBox_lat_deg.value(), self.doubleSpinBox_lat_min.value(),
                                        self.spinBox_lon_deg.value(), self.doubleSpinBox_lon_min.value(),
                                        self.comboBox_ns.currentText(), self.comboBox_we.currentText())
        self.entry["point"] = Point4d(dt, pos[0], pos[1])
        self.entry["fixtype"] = self.sourceEdit.text()
        if self.entry["fixtype"] == "":
            del self.entry["fixtype"]
        self.entry["log"] = self.logEdit.value()
        if self.entry["log"] < 0:
            del self.entry["log"]
        self.entry["cog"] = self.cogEdit.value()
        if self.entry["cog"] < 0:
            del self.entry["cog"]
        self.entry["heading"] = self.headingEdit.value()
        if self.entry["heading"] < 0:
            del self.entry["heading"]
        self.entry["sog"] = self.sogEdit.value()
        if self.entry["sog"] < 0:
            del self.entry["sog"]
        self.entry["stw"] = self.stwEdit.value()
        if self.entry["stw"] < 0:
            del self.entry["stw"]
        self.entry["enginehours"] = self.engineEdit.value()
        if self.entry["enginehours"] < 0:
            del self.entry["enginehours"]
        self.entry["tws"] = self.twsEdit.value()
        if self.entry["tws"] < 0:
            del self.entry["tws"]
        self.entry["twd"] = self.twdEdit.value()
        if self.entry["twd"] < 0:
            del self.entry["twd"]
        self.entry["airpressure"] = self.pressureEdit.value()
        if self.entry["airpressure"] < 870:
            del self.entry["airpressure"]
        self.entry["airtemperature"] = self.airtempSpinBox.value()
        if self.entry["airtemperature"] < -70:
            del self.entry["airtemperature"]
        self.entry["seastate"] = self.seastateBox.currentIndex()
        if self.entry["seastate"] == 0:
            del self.entry["seastate"]
        self.entry["cloudcover"] = self.cloudcoverSpinBox.value()
        if self.entry["cloudcover"] < 0:
            del self.entry["cloudcover"]
        self.entry["visibility"] = self.visibilityBox.currentIndex()
        if self.entry["visibility"] == 0:
            del self.entry["visibility"]
        self.entry["crewNames"] = []
        for i in range(self.crewBox.count()):
            self.entry["crewNames"].append(self.crewBox.item(i).text())
        self.entry["place"] = self.lineEdit_place.text()
        if self.entry["place"] == "":
            del self.entry["place"]
        self.entry["text"] = self.TextEdit.toPlainText()
        if self.entry["text"] == "":
            del self.entry["text"]

    def cancel_edit(self):
        self.entry = {}
        self.close()


class SettingsDialog(Ui_DialogSettings, QtWidgets.QDialog):
    def __init__(self, parent=None, conf={}):
        super().__init__(parent)
        self.setupUi(self)
        self.conf = conf
        self.updatevalues()
        self.buttonBox.accepted.connect(self.applyValues)
        self.buttonBox.rejected.connect(self.cancel_edit)
        self.qplPathButton.clicked.connect(self.qplog_dir)
        self.sklPathButton.clicked.connect(self.sklog_dir)


    def qplog_dir(self):
        #print("qplog")
        path = QFileDialog.getExistingDirectory(self, "Select Directory")
        self.lineEdit_qplog_dir.setText(path)

    def sklog_dir(self):
        path = QFileDialog.getExistingDirectory(self, "Select Directory")
        self.lineEdit_sklog_dir.setText(path)

    def updatevalues(self):
        # update the values in the Settings Dialog according to the current configuration file
        self.lineEdit_name.setText(self.conf["boat"]["name"])
        self.lineEdit_call_sign.setText(self.conf["boat"]["callsign"])
        self.spinBox_mmsi.setValue(self.conf["boat"]["mmsi"])
        self.doubleSpinBox_hight.setValue(self.conf["boat"]["hight"])
        self.doubleSpinBox_beam.setValue(self.conf["boat"]["beam"])
        self.doubleSpinBox_loa.setValue(self.conf["boat"]["loa"])
        self.doubleSpinBox_draft.setValue(self.conf["boat"]["draft"])
        self.spinBox_update_interv.setValue(self.conf["loginterv"])
        self.spinBox_track_interv.setValue(self.conf["trackinterv"])
        self.doubleSpinBox_timeout.setValue(self.conf["servertimeout"])
        self.lineEdit_qplog_dir.setText(self.conf["qplogfolder"])
        self.lineEdit_sklog_dir.setText(self.conf["sklogfolder"])
        self.lineEdit_server.setText(self.conf["skserver"])
        self.doubleSpinBox_indexerror.setValue(self.conf["indexerror"])
        self.doubleSpinBox_hoe.setValue(self.conf["hightofeye"])
        self.doubleSpinBox_UTCoffset.setValue(self.conf["utc_offset"])

        self.checkBox_autoentry.setChecked(self.conf["enableauto"])
        self.checkBox_evententrys.setChecked(self.conf["enableeventlog"])
        self.checkBox_manualmode.setChecked(self.conf["manualmode"])

        self.lineEdit_datetime.setText(self.conf["path"]["datetime"])
        self.lineEdit_position.setText(self.conf["path"]["position"])
        self.lineEdit_log.setText(self.conf["path"]["log"])
        self.lineEdit_engine.setText(self.conf["path"]["enginehours"])
        self.lineEdit_sog.setText(self.conf["path"]["sog"])
        self.lineEdit_cog.setText(self.conf["path"]["cog"])
        self.lineEdit_heading.setText(self.conf["path"]["heading"])
        self.lineEdit_stw.setText(self.conf["path"]["stw"])
        self.lineEdit_tws.setText(self.conf["path"]["tws"])
        self.lineEdit_twd.setText(self.conf["path"]["twd"])
        self.lineEdit_temp.setText(self.conf["path"]["airtemperature"])
        self.lineEdit_airpressure.setText(self.conf["path"]["airpressure"])
        self.lineEdit_humidity.setText(self.conf["path"]["humidity"])
        self.lineEdit_hdop.setText(self.conf["path"]["hdop"])
        self.lineEdit_fix.setText(self.conf["path"]["fixtype"])
        self.lineEdit_rpm.setText(self.conf["path"]["rpm"])

        self.checkBox_log.setChecked(True) if "log" in self.conf["activekeys"] else self.checkBox_log.setChecked(False)
        self.checkBox_engine.setChecked(True) if "enginehours" in self.conf["activekeys"] else self.checkBox_engine.setChecked(False)
        self.checkBox_sog.setChecked(True) if "sog" in self.conf["activekeys"] else self.checkBox_sog.setChecked(False)
        self.checkBox_cog.setChecked(True) if "cog" in self.conf["activekeys"] else self.checkBox_cog.setChecked(False)
        self.checkBox_heading.setChecked(True) if "heading" in self.conf["activekeys"] else self.checkBox_heading.setChecked(False)
        self.checkBox_stw.setChecked(True) if "stw" in self.conf["activekeys"] else self.checkBox_stw.setChecked(False)
        self.checkBox_tws.setChecked(True) if "tws" in self.conf["activekeys"] else self.checkBox_tws.setChecked(False)
        self.checkBox_twd.setChecked(True) if "twd" in self.conf["activekeys"] else self.checkBox_twd.setChecked(False)
        self.checkBox_temp.setChecked(True) if "airtemperature" in self.conf["activekeys"] else self.checkBox_temp.setChecked(False)
        self.checkBox_airpressure.setChecked(True) if "airpressure" in self.conf["activekeys"] else self.checkBox_airpressure.setChecked(False)
        self.checkBox_humidity.setChecked(True) if "humidity" in self.conf["activekeys"] else self.checkBox_humidity.setChecked(False)
        self.checkBox_hdop.setChecked(True) if "hdop" in self.conf["activekeys"] else self.checkBox_hdop.setChecked(False)
        self.checkBox_fix.setChecked(True) if "fixtype" in self.conf["activekeys"] else self.checkBox_fix.setChecked(False)
        self.checkBox_rpm.setChecked(True) if "rpm" in self.conf["activekeys"] else self.checkBox_rpm.setChecked(False)

        self.checkBox_s_log.setChecked(True) if "log" in self.conf["showkeys"] else self.checkBox_s_log.setChecked(False)
        self.checkBox_s_engine.setChecked(True) if "enginehours" in self.conf["showkeys"] else self.checkBox_s_engine.setChecked(False)
        self.checkBox_s_sog.setChecked(True) if "sog" in self.conf["showkeys"] else self.checkBox_s_sog.setChecked(False)
        self.checkBox_s_cog.setChecked(True) if "cog" in self.conf["showkeys"] else self.checkBox_s_cog.setChecked(False)
        self.checkBox_s_heading.setChecked(True) if "heading" in self.conf["showkeys"] else self.checkBox_s_heading.setChecked(False)
        self.checkBox_s_stw.setChecked(True) if "stw" in self.conf["showkeys"] else self.checkBox_s_stw.setChecked(False)
        self.checkBox_s_tws.setChecked(True) if "tws" in self.conf["showkeys"] else self.checkBox_s_tws.setChecked(False)
        self.checkBox_s_twd.setChecked(True) if "twd" in self.conf["showkeys"] else self.checkBox_s_twd.setChecked(False)
        self.checkBox_s_temp.setChecked(True) if "airtemperature" in self.conf["showkeys"] else self.checkBox_s_temp.setChecked(False)
        self.checkBox_s_airpressure.setChecked(True) if "airpressure" in self.conf["showkeys"] else self.checkBox_s_airpressure.setChecked(False)
        self.checkBox_s_humidity.setChecked(True) if "humidity" in self.conf["showkeys"] else self.checkBox_s_humidity.setChecked(False)
        self.checkBox_s_hdop.setChecked(True) if "hdop" in self.conf["showkeys"] else self.checkBox_s_hdop.setChecked(False)
        self.checkBox_s_fix.setChecked(True) if "fixtype" in self.conf["showkeys"] else self.checkBox_s_fix.setChecked(False)
        self.checkBox_s_rpm.setChecked(True) if "rpm" in self.conf["showkeys"] else self.checkBox_s_rpm.setChecked(False)
        self.checkBox_s_seastate.setChecked(True) if "seastate" in self.conf["showkeys"] else self.checkBox_s_seastate.setChecked(False)
        self.checkBox_s_cloud.setChecked(True) if "cloudcover" in self.conf["showkeys"] else self.checkBox_s_cloud.setChecked(False)
        self.checkBox_s_visibility.setChecked(True) if "visibility" in self.conf["showkeys"] else self.checkBox_s_visibility.setChecked(False)
        self.checkBox_s_crew.setChecked(True) if "crewNames" in self.conf["showkeys"] else self.checkBox_s_crew.setChecked(False)
        self.checkBox_s_text.setChecked(True) if "text" in self.conf["showkeys"] else self.checkBox_s_text.setChecked(False)
        self.checkBox_s_place.setChecked(True) if "place" in self.conf["showkeys"] else self.checkBox_s_place.setChecked(False)
        self.checkBox_s_status.setChecked(True) if "status" in self.conf["showkeys"] else self.checkBox_s_status.setChecked(False)


    def applyValues(self):
        self.conf["boat"]["name"] = self.lineEdit_name.text()
        self.conf["boat"]["callsign"] = self.lineEdit_call_sign.text()
        self.conf["boat"]["mmsi"] = self.spinBox_mmsi.value()
        self.conf["boat"]["hight"] = self.doubleSpinBox_hight.value()
        self.conf["boat"]["beam"] = self.doubleSpinBox_beam.value()
        self.conf["boat"]["loa"] = self.doubleSpinBox_loa.value()
        self.conf["boat"]["draft"] = self.doubleSpinBox_draft.value()
        self.conf["loginterv"] = self.spinBox_update_interv.value()
        self.conf["trackinterv"] = self.spinBox_track_interv.value()
        self.conf["servertimeout"] = self.doubleSpinBox_timeout.value()
        self.conf["qplogfolder"] = self.lineEdit_qplog_dir.text()
        self.conf["sklogfolder"] = self.lineEdit_sklog_dir.text()
        self.conf["skserver"] = self.lineEdit_server.text()
        self.conf["indexerror"] = self.doubleSpinBox_indexerror.value()
        self.conf["hightofeye"] = self.doubleSpinBox_hoe.value()
        self.conf["utc_offset"] = self.doubleSpinBox_UTCoffset.value()


        m_window.scheduler.reschedule_job("track", trigger="cron", minute=f"*/{int(conf['trackinterv'])}")
        m_window.scheduler.reschedule_job("entry", trigger="cron", hour=f"*/{conf['loginterv']}")

        self.conf["enableauto"] = self.checkBox_autoentry.isChecked()
        self.conf["enableeventlog"] = self.checkBox_evententrys.isChecked()
        self.conf["manualmode"] = self.checkBox_manualmode.isChecked()

        self.conf["path"]["datetime"] = self.lineEdit_datetime.text()
        self.conf["path"]["position"] = self.lineEdit_position.text()
        self.conf["path"]["log"] = self.lineEdit_log.text()
        self.conf["path"]["enginehours"] = self.lineEdit_engine.text()
        self.conf["path"]["sog"] = self.lineEdit_sog.text()
        self.conf["path"]["cog"] = self.lineEdit_cog.text()
        self.conf["path"]["heading"] = self.lineEdit_heading.text()
        self.conf["path"]["stw"] = self.lineEdit_stw.text()
        self.conf["path"]["tws"] = self.lineEdit_tws.text()
        self.conf["path"]["twd"] = self.lineEdit_twd.text()
        self.conf["path"]["airtemperature"] = self.lineEdit_temp.text()
        self.conf["path"]["airpressure"] = self.lineEdit_airpressure.text()
        self.conf["path"]["humidity"] = self.lineEdit_humidity.text()
        self.conf["path"]["hdop"] = self.lineEdit_hdop.text()
        self.conf["path"]["fixtype"] = self.lineEdit_fix.text()
        self.conf["path"]["rpm"] = self.lineEdit_rpm.text()

        self.conf["activekeys"] = []
        if self.checkBox_log.isChecked(): self.conf["activekeys"].append("log")
        if self.checkBox_engine.isChecked(): self.conf["activekeys"].append("enginehours")
        if self.checkBox_sog.isChecked(): self.conf["activekeys"].append("sog")
        if self.checkBox_cog.isChecked(): self.conf["activekeys"].append("cog")
        if self.checkBox_heading.isChecked(): self.conf["activekeys"].append("heading")
        if self.checkBox_stw.isChecked(): self.conf["activekeys"].append("stw")
        if self.checkBox_tws.isChecked(): self.conf["activekeys"].append("tws")
        if self.checkBox_twd.isChecked(): self.conf["activekeys"].append("twd")
        if self.checkBox_temp.isChecked(): self.conf["activekeys"].append("airtemperature")
        if self.checkBox_airpressure.isChecked(): self.conf["activekeys"].append("airpressure")
        if self.checkBox_humidity.isChecked(): self.conf["activekeys"].append("humidity")
        if self.checkBox_hdop.isChecked(): self.conf["activekeys"].append("hdop")
        if self.checkBox_fix.isChecked(): self.conf["activekeys"].append("fixtype")
        if self.checkBox_rpm.isChecked(): self.conf["activekeys"].append("rpm")

        self.conf["showkeys"] = []
        if self.checkBox_s_log.isChecked(): self.conf["showkeys"].append("log")
        if self.checkBox_s_engine.isChecked(): self.conf["showkeys"].append("enginehours")
        if self.checkBox_s_sog.isChecked(): self.conf["showkeys"].append("sog")
        if self.checkBox_s_cog.isChecked(): self.conf["showkeys"].append("cog")
        if self.checkBox_s_heading.isChecked(): self.conf["showkeys"].append("heading")
        if self.checkBox_s_stw.isChecked(): self.conf["showkeys"].append("stw")
        if self.checkBox_s_tws.isChecked(): self.conf["showkeys"].append("tws")
        if self.checkBox_s_twd.isChecked(): self.conf["showkeys"].append("twd")
        if self.checkBox_s_temp.isChecked(): self.conf["showkeys"].append("airtemperature")
        if self.checkBox_s_airpressure.isChecked(): self.conf["showkeys"].append("airpressure")
        if self.checkBox_s_humidity.isChecked(): self.conf["showkeys"].append("humidity")
        if self.checkBox_s_hdop.isChecked(): self.conf["showkeys"].append("hdop")
        if self.checkBox_s_fix.isChecked(): self.conf["showkeys"].append("fixtype")
        if self.checkBox_s_rpm.isChecked(): self.conf["showkeys"].append("rpm")
        if self.checkBox_s_seastate.isChecked(): self.conf["showkeys"].append("seastate")
        if self.checkBox_s_cloud.isChecked(): self.conf["showkeys"].append("cloudcover")
        if self.checkBox_s_visibility.isChecked(): self.conf["showkeys"].append("visibility")
        if self.checkBox_s_crew.isChecked(): self.conf["showkeys"].append("crewNames")
        if self.checkBox_s_text.isChecked(): self.conf["showkeys"].append("text")
        if self.checkBox_s_place.isChecked(): self.conf["showkeys"].append("place")
        if self.checkBox_s_status.isChecked(): self.conf["showkeys"].append("status")
        self.close()

              

    def cancel_edit(self):
        self.close()


def save_and_merge():
    """
    Merges the current log into the active folder and splits the log into monthly files without user interaction.

    This function performs the following steps:
    1. Splits the current log into monthly files.
    2. For each monthly file:
        - If the file already exists:
            - Reads the existing log.
            - Compares the existing log with the new log.
            - If they are different, merges the logs, cleans up the merged log, and writes it back to the file.
        - If the file does not exist:
            - Writes the new log to a new file.

    Raises:
        FileNotFoundError: If the specified log file is not found.
    """
    to_save = iofunctions.splitmonthly(QPlog)
    for key in to_save:
        try:
            with open(f"{conf['qplogfolder']}/{key}.json", "r") as file:
                oldjson = file.read()
                newjson = iofunctions.serialize_log(to_save[key])
                if oldjson == newjson:
                    pass
                else:               
                    with open(f"{conf['qplogfolder']}/{key}.json", "r") as file:
                        oldlog = iofunctions.deserialize_log(file.read())
                    oldlog.extend(to_save[key])
                    oldlog = iofunctions.cleanup(oldlog)
                    with open(f"{conf['qplogfolder']}/{key}.json", "w") as file:
                        file.write(iofunctions.serialize_log(oldlog))
        except FileNotFoundError:
            with open(f"{conf['qplogfolder']}/{key}.json", "w") as file:
                file.write(iofunctions.serialize_log(to_save[key]))


def sig_handler(*args):
    """Handler for the SIGINT and SIGTERM signals"""
    save_and_merge()
    QtWidgets.QApplication.exit()

signal.signal(signal.SIGINT, sig_handler) # Register the handler for the SIGINT signal
signal.signal(signal.SIGTERM, sig_handler) # Register the handler for the SIGTERM signal


# Main Loop:
app = QtWidgets.QApplication(sys.argv)

# Timer to let the Python interpreter run form time to time to catch signals:
timer = QTimer()
timer.start(500)  
timer.timeout.connect(lambda: None)

m_window = MainWindow()
if conf["qplogfolder"] == "":
    m_window.firststart()
app.setWindowIcon(QtGui.QIcon(':/icons/SVG/Sextantcolor.svg'))
m_window.setWindowTitle("QPLogbook")
m_window.show()
app.exec()